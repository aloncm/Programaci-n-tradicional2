<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Programación Tradicional - Historia y Evolución</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="header">
        <div class="container">
            <h1 class="header-title">Programación Tradicional</h1>
            <p class="header-subtitle">Un viaje a través de la historia de la programación</p>
        </div>
    </header>

  <nav class="tabs">
    <div class="container">
        <!-- Radio buttons -->
        <input type="radio" id="tab1" name="tabs" checked>
        <input type="radio" id="tab2" name="tabs">
        <input type="radio" id="tab3" name="tabs">
        <input type="radio" id="tab4" name="tabs">
        <input type="radio" id="tab5" name="tabs">
        <input type="radio" id="tab6" name="tabs">
        <input type="radio" id="tab7" name="tabs">

              <div class="tab-labels">
            <label for="tab1" class="tab-label">General</label>
            <label for="tab2" class="tab-label">Pac-Man</label>
            <label for="tab3" class="tab-label">Doom</label>
            <label for="tab4" class="tab-label">Lenguajes</label>
            <label for="tab5" class="tab-label">Ejemplos</label>
            <label for="tab6" class="tab-label">Preguntas</label>
            <label for="tab7" class="tab-label">Alonsillo</label>
        </div>

            <div class="tab-contents">
                <!-- TAB 1: GENERAL -->
                <div class="tab-content">
                    <div class="hero-section">
                        <img src="https://images.pexels.com/photos/546819/pexels-photo-546819.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1" alt="Computadora vintage" class="hero-image">
                        <div class="hero-text">
                            <h2>¿Qué es la Programación Tradicional?</h2>
                            <p>
¿Por qué se le llama programación tradicional?<br>

Se le llama “tradicional” porque fue el primer modelo formalmente adoptado en la industria y la educación. Sentó las bases de la programación moderna y fue utilizado en las primeras aplicaciones científicas, comerciales y de entretenimiento.<br>

 La programación tradicional fue la columna vertebral del software en los años 50 a 80, y aunque hoy existen paradigmas más avanzados, muchos de sus principios aún siguen presentes en la programación actual.</p>
                        </div>
                    </div>

                    <div class="content-grid">
                        <div class="card">
                            <h3>Características Principales</h3>
                            <ul>
                                <li><strong>Programación Secuencial:</strong> Código ejecutado línea por línea</li>
                                <li><strong>Memoria Limitada:</strong> Optimización extrema de recursos</li>
                                <li><strong>Bajo Nivel:</strong> Control directo del hardware</li>
                                <li><strong>Compilación Directa:</strong> Traducción directa a código máquina</li>
                            </ul>
                        </div>

                        <div class="card">
                            <h3>Paradigmas Dominantes</h3>
                            <ul>
                                <li><strong>Programación Imperativa:</strong> Instrucciones paso a paso</li>
                                <li><strong>Programación Estructurada:</strong> Uso de funciones y procedimientos</li>
                                <li><strong>Programación Modular:</strong> División en módulos independientes</li>
                                <li><strong>Batch Processing:</strong> Procesamiento por lotes</li>
                            </ul>
                        </div>
                         <div class="card">
                            <h3>Limitaciones y Desafíos</h3>
                            <ul>
                                <li><strong>Escasa Interfaz Gráfica:</strong> La mayoría de programas solo tenían texto.</li>
                                <li><strong>Mantenimiento Difícil:</strong> Los cambios eran costosos y propensos a errores.</li>
                                <li><strong>Dependencia de Hardware:</strong> Portar un programa de una máquina a otra era muy complicado.</li>
                                <li><strong>Errores Críticos:</strong>Un fallo de memoria podía bloquear todo el sistema.</li>
                            </ul>
                        </div>

                        <div class="card full-width">
                            <h3>Evolución Histórica</h3>
                            <div class="timeline">
                                <div class="timeline-item">
                                    <div class="timeline-year">1940s</div>
                                    <div class="timeline-content">Primeros ordenadores - Programación en código máquina</div>
                                </div>
                                <div class="timeline-item">
                                    <div class="timeline-year">1950s</div>
                                    <div class="timeline-content">Lenguaje ensamblador - FORTRAN (1957)</div>
                                </div>
                                <div class="timeline-item">
                                    <div class="timeline-year">1960s</div>
                                    <div class="timeline-content">COBOL, ALGOL - Programación estructurada</div>
                                </div>
                                <div class="timeline-item">
                                    <div class="timeline-year">1970s</div>
                                    <div class="timeline-content">Pascal, C - Programación modular</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- TAB 2: PAC-MAN -->
                <div class="tab-content">
                    <div class="hero-section">
                     <img src="0d8aa8f801110e12d78ebd96fe01ead2.gif" alt="Preguntas sobre programación" class="hero-image">

                        <div class="hero-text">
                            <h2>Pac-Man (1980) - Un Clásico de la Programación</h2>
                            <p>Descubre cómo la programación tradicional dio vida a uno de los juegos más icónicos de la historia.<br>
                            Desarrollador: Namco – Toru Iwatani<br>
Lanzamiento: 1980 (Arcade original)</p>
                        </div>
                    </div>

                    <div class="content-grid">
                        <div class="card">
                            <h3>Especificaciones Técnicas</h3>
                            <ul>
                                <li><strong>CPU:</strong> Zilog Z80 (3.072 MHz)</li>
                                <li><strong>RAM:</strong> 2KB para programa, 2KB para video</li>
                                <li><strong>Lenguaje:</strong> Ensamblador Z80</li>
                                <li><strong>Pantalla:</strong> 224×288 píxeles</li>
                            </ul>
                        </div>

                        <div class="card">
                            <h3>Algoritmos Clave</h3>
                            <ul>
                                <li><strong>Pathfinding:</strong> Algoritmo simple de persecución</li>
                                <li><strong>Estado de Fantasmas:</strong> Máquina de estados finitos</li>
                                <li><strong>Colisiones:</strong> Detección basada en tiles</li>
                                <li><strong>Animación:</strong> Sprites intercambiados por frame</li>
                            </ul>
                        </div>
                         <div class="card">
                            <h3>Innovaciones Técnicas</h3>
                            <ul>
                                <li><strong>Mapeado con Tiles:</strong> Todo el laberinto estaba diseñado en bloques reutilizables para ahorrar memoria.</li>
                                <li><strong>Sprites Simples:</strong> Cada fantasma usaba apenas 16 bytes de memoria gráfica.</li>
                                <li><strong>Interactividad Dinámica:</strong> La velocidad de los fantasmas aumentaba a medida que Pac-Man comía más puntos</li>
                                <li><strong>Sonido Iconico:</strong> Efectos generados con osciladores simples, ligados directamente a eventos de juego.</li>
                            </ul>
                        </div>

                        <div class="code-example">
                            <h3>Ejemplo de Código (Pseudocódigo en estilo Z80)</h3>
                            <pre><code>; Movimiento básico de Pac-Man
MOVE_PACMAN:
    LD A, (INPUT_PORT)    ; Leer entrada del joystick
    CP MOVE_UP           ; ¿Movimiento hacia arriba?
    JR Z, MOVE_UP_PROC   ; Si es así, saltar a rutina
    CP MOVE_DOWN         ; ¿Movimiento hacia abajo?
    JR Z, MOVE_DOWN_PROC ; Si es así, saltar a rutina
    ; ... continúa para todas las direcciones
    RET

; Detección de colisión con fantasma
CHECK_GHOST_COLLISION:
    LD HL, PACMAN_X      ; Cargar posición X de Pac-Man
    LD DE, GHOST_X       ; Cargar posición X del fantasma
    OR A                 ; Limpiar carry flag
    SBC HL, DE           ; Restar posiciones
    JR Z, COLLISION      ; Si son iguales, hay colisión
    RET</code></pre>
                        </div>

                        <div class="card full-width">
                            <h3>Innovaciones Técnicas</h3>
                            <p><strong>IA de Fantasmas:</strong> Cada fantasma tenía una personalidad única programada con diferentes algoritmos de persecución. Blinky perseguía directamente, Pinky anticipaba movimientos, Inky era impredecible, y Clyde alternaba entre perseguir y huir.<br>
                            Este diseño evitaba la monotonía y daba la ilusión de inteligencia avanzada usando solo algoritmos simples.</p>
                            <br><p><strong>Optimización de Memoria:</strong> RAM limitada: Pac-Man solo disponía de 4KB en total (2KB para lógica y 2KB para video), lo que obligaba a usar técnicas extremas de optimización.<br>

Tiles reutilizables: Los escenarios y sprites estaban hechos con bloques gráficos pequeños reutilizados múltiples veces.<br>

Compresión manual: Muchos sprites estaban comprimidos en memoria y luego “desempaquetados” en tiempo real para ahorrar espacio.</p>
<br><p><strong>Máquina de Estados Finita (FSM)</strong> El comportamiento de los fantasmas se organizó en modos de estado:<br>

Scatter (dispersión): Los fantasmas se dirigían a esquinas específicas.<br>

Chase (persecución): Actuaban según su algoritmo de persecución.<br>

Frightened (asustados): Tras comer un “power pellet”, huían al azar.<br>

Este sistema simple pero eficaz fue precursor de las IA modernas en videojuegos</p>                        

<br><p><strong>Animaciones Simples pero Eficientes</strong> Pac-Man abría y cerraba la boca alternando dos sprites diferentes en bucle.<br>

Los fantasmas usaban variaciones mínimas en sus sprites (ojos y color) para simular dirección y estado.<br>

Esta técnica ahorraba memoria y procesador, a la vez que generaba una animación fluida.</p>                        
</div>
</div>
                    </div>
             
               
                <div class="tab-content">
                    <div class="hero-section">
                      <img src="d726d84bba16ace8eef46c70db213521.gif" alt="Preguntas sobre programación" class="hero-image">
                        <div class="hero-text">
                            <h2>Doom (1993) - Revolución en 3D</h2>
                            <p>Cómo la programación tradicional optimizada logró crear el primer shooter 3D exitoso en PCs limitados.</p>
                        </div>
                    </div>

                    <div class="content-grid">
                        <div class="card">
                            <h3>Especificaciones Mínimas</h3>
                            <ul>
                                <li><strong>CPU:</strong> 386DX (25 MHz)</li>
                                <li><strong>RAM:</strong> 4MB</li>
                                <li><strong>Lenguaje:</strong> C y Ensamblador</li>
                                <li><strong>Gráficos:</strong> VGA 320×200</li>
                            </ul>
                        </div>

                        <div class="card">
                            <h3>Técnicas Avanzadas</h3>
                            <ul>
                                <li><strong>BSP Trees:</strong> Renderizado eficiente de niveles</li>
                                <li><strong>Raycasting:</strong> Simulación 3D en 2D</li>
                                <li><strong>Visplanes:</strong> Optimización de superficies</li>
                                <li><strong>Sector-based:</strong> Arquitectura modular de niveles</li>
                            </ul>
                            
                        </div>
                        <div class="card">
                            <h3>Binary Space Partitioning para colisiones:</h3>
                            <p>DOOM aprovechaba la estructura de datos BSP no solo para renderizar los niveles de manera eficiente, sino también para gestionar las colisiones de los jugadores, enemigos y proyectiles.</p>
                        </div>

                        <div class="code-example">
                            <h3>Ejemplo de Algoritmo BSP (Pseudocódigo)</h3>
                            <pre><code>// Algoritmo BSP para renderizado eficiente
void RenderBSPNode(bspnode_t *node, player_t *player)
{
    if (!node) return;
    
    // Determinar en qué lado del nodo está el jugador
    int side = PointOnSide(player->x, player->y, node->line);
    
    // Renderizar primero el lado lejano (back-to-front)
    RenderBSPNode(node->children[!side], player);
    
    // Renderizar la línea divisoria si es visible
    if (LineIsVisible(node->line, player))
    {
        RenderWall(node->line);
    }
    
    // Renderizar el lado cercano
    RenderBSPNode(node->children[side], player);
}

// Optimización de memoria para sprites
void DrawSprite(sprite_t *sprite)
{
    // Usar lookup tables para cálculos trigonométricos
    int distance = sintable[angle] * sprite->x + costable[angle] * sprite->y;
    int scale = FixedDiv(PROJECTION, distance);
    
    // Dibujar solo los pixels visibles
    DrawScaledColumn(sprite->patch, scale);
}</code></pre>
                        </div>

                        <div class="card full-width">
                            <h3>Innovaciones Revolucionarias</h3>
                            <p><strong>Motor BSP:</strong> John Carmack implementó un avanzado sistema de Binary Space Partitioning (BSP) que revolucionó la forma de renderizar los niveles en DOOM. Este motor dividía cada mapa en secciones jerárquicas, lo que permitía al juego dibujar solo las superficies visibles desde la perspectiva del jugador, evitando procesar toda la geometría del nivel en cada frame. Gracias a esta técnica, DOOM podía manejar entornos 3D complejos con paredes, pasillos y habitaciones interconectadas, manteniendo un rendimiento fluido incluso en computadoras con recursos limitados. Además, el BSP facilitaba la gestión de colisiones y la detección de visibilidad de enemigos y proyectiles, integrando varias funciones críticas del motor en una estructura de datos eficiente.</p>
                            <p><strong>Networking Multiplayer:</strong> DOOM también marcó un hito en los videojuegos al introducir el multijugador por red de manera innovadora. Utilizaba un protocolo basado en UDP diseñado específicamente para minimizar el tráfico de datos y mantener la sincronización entre los jugadores. En lugar de enviar todo el estado del juego a través de la red, se transmitían únicamente los comandos de los jugadores, como movimientos y disparos. Esto reducía significativamente la carga de la red y permitía partidas en tiempo real con retrasos mínimos, sentando las bases de los shooters multijugador modernos. Esta arquitectura también permitía partidas cooperativas o competitivas en entornos LAN, un concepto prácticamente nuevo para la época.</p>
                        </div>
                    </div>
                </div>

                <!-- TAB 4: LENGUAJES -->
      
                <!-- TAB 1: GENERAL -->
                <div class="tab-content">
                    <div class="hero-section">
                        <img src="https://images.pexels.com/photos/270348/pexels-photo-270348.jpeg?auto=compress&cs=tinysrgb&w=1260&h=750&dpr=1" alt="Programming languages" class="hero-image">
                        <div class="hero-text">
                            <h2>Lenguajes de Programación Tradicionales</h2>
                            <p>Los pioneros que sentaron las bases de la programación moderna.</p>
                        </div>
                    </div>

                    <div class="card">
                            <div class="language-header">
                                <h3>FORTRAN (1957)</h3>
                                <span class="language-year">Formula Translation</span>
                            </div>
                            <p><strong>Creador:</strong> IBM - John Backus</p>
                            <p><strong>Propósito:</strong> Cálculos científicos y matemáticos</p>
                           <div class="code-example">
                                <h4>Ejemplo - Cálculo de Factorial:</h4>
                                <pre><code>      PROGRAM FACTORIAL
      INTEGER N, FACT, I
      WRITE(*,*) 'ENTER A NUMBER:'
      READ(*,*) N
      FACT = 1
      DO 10 I = 1, N
         FACT = FACT * I
   10 CONTINUE
      WRITE(*,*) 'FACTORIAL IS:', FACT
      END</code></pre>
                            </div>
                        </div>

                        <div class="language-card">
                            <div class="language-header">
                                <h3>COBOL (1959)</h3>
                                <span class="language-year">Common Business-Oriented Language</span>
                            </div>
                            <p><strong>Creador:</strong> Grace Hopper y equipo</p>
                            <p><strong>Propósito:</strong> Aplicaciones comerciales y de negocios</p>
                            <div class="code-example">
                                <h4>Ejemplo - Proceso de Nómina:</h4>
                                <pre><code>IDENTIFICATION DIVISION.
PROGRAM-ID. PAYROLL.
DATA DIVISION.
WORKING-STORAGE SECTION.
01 EMPLOYEE-RECORD.
   05 EMP-NAME        PIC X(30).
   05 HOURS-WORKED    PIC 9(2).
   05 HOURLY-RATE     PIC 9(2)V99.
   05 GROSS-PAY       PIC 9(4)V99.
PROCEDURE DIVISION.
COMPUTE GROSS-PAY = HOURS-WORKED * HOURLY-RATE.
DISPLAY "GROSS PAY: " GROSS-PAY.</code></pre>
                            </div>
                        </div>

                          <div class="card full-width">
    <h3>Pascal (1970)</h3>
    <span class="language-year">Programación Estructurada</span>
    <p><strong>Creador:</strong> Niklaus Wirth</p>
    <p><strong>Propósito:</strong> Enseñanza y programación estructurada</p>
    <div class="code-example">
        <h4>Ejemplo - Ordenamiento Burbuja:</h4>
        <pre><code>program BubbleSort;
var
  arr: array[1..10] of integer;
  i, j, temp, n: integer;
begin
  n := 10;
  { Leer números }
  for i := 1 to n do
    read(arr[i]);
  
  { Algoritmo burbuja }
  for i := 1 to n-1 do
    for j := 1 to n-i do
      if arr[j] > arr[j+1] then
      begin
        temp := arr[j];
        arr[j] := arr[j+1];
        arr[j+1] := temp;
      end;
end.</code></pre>
    </div>
</div>
  <div class="card">
                            <div class="language-header">
                                <h3>ALGOL (1960)</h3>
                                <span class="language-year">Algorithmic Language</span>
                            </div>
                            <p><strong>Creador:</strong> Comité de ACM y GAMM</p>
                            <p><strong>Propósito:</strong>Expresar algoritmos de manera estructurada y estandarizada, base para muchos lenguajes posteriores.</p>
                           <div class="code-example">
                                <h4>Ejemplo - Suma de N números:</h4>
                                <pre><code>      PROGRAM FACTORIAL
     begin
  integer n, i, sum;
  sum := 0;
  read(n);
  for i := 1 step 1 until n do
    sum := sum + i;
  print(sum);
end
</code></pre>
                            </div>
                        </div>
                         <div class="card">
                            <div class="language-header">
                                <h3>BASIC (1964)</h3>
                                <span class="language-year">Beginner’s All-purpose Symbolic Instruction Code</span>
                            </div>
                            <p><strong>Creador:</strong> John Kemeny y Thomas Kurtz (Dartmouth College)</p>
                            <p><strong>Propósito:</strong>Enseñanza de programación y desarrollo rápido de aplicaciones sencillas.</p>
                           <div class="code-example">
                                <h4>Ejemplo - Imprimir números del 1 al 10:</h4>
                                <pre><code>      PROGRAM FACTORIAL
  10 FOR I = 1 TO 10
20 PRINT I
30 NEXT I

</code></pre>
                            </div>
                        </div>
                         <div class="card">
                            <div class="language-header">
                                <h3>Assembly (década de 1950-1960)</h3>
                                <span class="language-year">Lenguaje Ensamblador</span>
                            </div>
                            <p><strong>Creador:</strong> Varios fabricantes de computadoras</p>
                            <p><strong>Propósito:</strong>Programación cercana al hardware, control total de recursos y optimización de rendimiento.</p>
                           <div class="code-example">
                                <h4>Ejemplo - Suma de dos números (x86):</h4>
                                <pre><code>      PROGRAM FACTORIAL
 MOV AX, 5
MOV BX, 3
ADD AX, BX
; AX ahora contiene 8
</code></pre>
                            </div>
                        </div>
                </div>  
                


        


<!-- TAB 5: EJEMPLOS -->
<div class="tab-content">
    <div class="hero-section">
        <img src="classic-game-control-free-vector.jpg" alt="Gaming history" class="hero-image">
        <div class="hero-text">
            <h2>Más Ejemplos Clásicos</h2>
            <p>Otros juegos y aplicaciones que marcaron la historia de la programación.</p>
        </div>
    </div>

    <div class="content-grid">
        <!-- Space Invaders -->
        <div class="example-card">
            <h3>Space Invaders (1978)</h3>
            <p><strong>Hardware:</strong> Intel 8080 (2 MHz)</p>
            <p><strong>Memoria:</strong> 8KB ROM, 1KB RAM</p>
            <p><strong>Innovación:</strong> Primer juego en usar dificultad progresiva...</p>
           <br>
            <img src="space-invaders.gif" alt="Preguntas sobre programación" class="hero-image">
            <div class="tech-detail">
                <strong>Truco Técnico:</strong> El aumento de velocidad era un "bug" convertido en feature.
             
            </div>
        </div>
        <!-- Tetris -->
        <div class="example-card">
            <h3>Tetris (1984)</h3>
            <p><strong>Plataforma:</strong> Electronika 60 (PDP-11 compatible)</p>
            <p><strong>Lenguaje:</strong> Pascal</p>
            <p><strong>Innovación:</strong> Algoritmo de rotación de piezas...</p>
             <br>
              <img src="demo.gif" alt="Preguntas sobre programación" class="hero-image">
            <div class="tech-detail">
                <strong>Algoritmo Clave:</strong> Detección de líneas completas mediante barrido de filas.
            </div>
        </div>
        <!-- Resto de juegos... -->
          <div class="example-card">
            <h3>Pong (1972)</h3>
            <p><strong>Hardware:</strong> TTL (Transistor-Transistor Logic) puro</p>
            <p><strong>Procesador:</strong> ¡Ninguno! Solo circuitos lógicos</p>
            <p><strong>Innovación:</strong> Primer videojuego comercial exitoso. La lógica del juego estaba completamente implementada en hardware, sin software.</p>
             <br>
             <img src="9a873b64d3fc756c633a6c23d4627560.gif" class="hero-image">
            
            <div class="tech-detail">
                <strong>Curiosidad:</strong> No había CPU ni programa - todo era circuitería analógica y digital pura.
            </div>
        </div>
            <div class="example-card">
                <h3>Donkey Kong (1981)</h3>
                <p><strong>Hardware:</strong> CPU Z80 (3.072 MHz)</p>
                <p><strong>Memoria:</strong> 16KB ROM, 1KB RAM</p>
                <p><strong>Innovación:</strong> Introducción de personajes con personalidad y narrativa simple...</p>
             <br>
             <img src="dkong_mame_screenshot.gif" alt="Preguntas sobre programación" class="hero-image">
            
                <div class="tech-detail">
                    <strong>Truco Técnico:</strong> Uso innovador de sprites para animaciones fluidas.
                </div>
    
            </div>
              <div class="example-card">
            <h3>Prince of Persia (1989)</h3>
            <p><strong>Plataforma:</strong> Apple II (1 MHz)</p>
            <p><strong>Memoria:</strong> 64KB</p>
            <p><strong>Innovación:</strong> Animación rotoscópica - animaciones realizadas filmando movimientos reales y digitalizándolos frame por frame.</p>
             <br>
             <img src="cinematic-platformer-prince-of-persia.gif" alt="Preguntas sobre programación" class="hero-image">
            
            <div class="tech-detail">
                <strong>Técnica: </strong>  Jordan Mechner filmó a su hermano corriendo y saltando, luego digitalizó cada frame manualmente.
            </div>
        </div>
        <div class="example-card">
            <h3>SimCity (1989)</h3>
            <p><strong>Lenguaje: </strong> C y Ensamblador</p>
            <p><strong>Innovación:</strong>Primer simulador complejo de ciudad con sistemas interconectados (electricidad, agua, tráfico, crimen). </p>
            <br>
            <img src="169987-3.gif" alt="Preguntas sobre programación" class="hero-image">
            
            <div class="tech-detail">
                <strong>Algoritmo: </strong>  Autómatas celulares para simular la propagación de problemas urbanos como el crimen y la contaminación.
            </div>
        </div>
        <div class="example-card">
            <h3>Elite (1984)</h3>
            <p><strong>Plataforma:</strong> BBC Micro (2 MHz)</p>
            <p><strong>Memoria: </strong>  32KB</p>
            <p><strong>Innovación:</strong> Universo 3D con 2048 sistemas solares generados proceduralmente usando solo 22KB de código.</p>
             <br>
              <img src="wVtrj2w.gif" alt="Preguntas sobre programación" class="hero-image">
            
            <div class="tech-detail">
                <strong>Magia:</strong>Generación procedimental con semillas matemáticas - cada sistema solar se generaba en tiempo real usando algoritmos deterministas
        </div>
        </div>
        <div class="example-card">
            <h3>Lode Runner (1983)</h3>
            <p><strong>Plataforma:</strong> Apple II, IBM PC</p>
            <p><strong>Lenguaje:</strong> Pascal, ensamblador</p>
            <p><strong>Memoria:</strong> 48KB</p>
             <br>
             <img src="n88K4v.gif" alt="Preguntas sobre programación" class="hero-image">
            
            <div class="tech-detail">
                <strong>Innovación:</strong> Plataformas con niveles complejos y enemigos con IA básica.
            </div>
        </div>
        <div class="example-card">
            <h3>The Bard's Tale (1985)</h3>
            <p><strong>Plataforma:</strong> Apple II</p>
            <p><strong>Lenguaje:</strong> BASIC y ensamblador</p>
            <p><strong>Memoria:</strong> 64KB</p>
             <br>
             <img src="11-Bard.gif" alt="Preguntas sobre programación" class="hero-image">
            
            <div class="tech-detail">
                <strong>Innovación:</strong> Juego de rol con mapas de mazmorras, combates estratégicos y narración avanzada
           
            </div>
        </div>
    </div>
</div>  

<!-- TAB 6: PREGUNTAS -->
<div class="tab-content">
    <div class="hero-section">
        <img src="certificacion-tecnica-ti-600x550.jpg" alt="Preguntas sobre programación" class="hero-image">
        <div class="hero-text">
            <h2>Preguntas Frecuentes sobre Programación Tradicional</h2>
            <p>Resuelve tus dudas más comunes sobre la programación tradicional y su historia.</p>
        </div>
    </div>


       <div class="example-card">
            <h3>¿Cómo funcionaba la programación tradicional?</h3>
            <p>•	Los programas se escribían como una serie de instrucciones secuenciales, que la computadora ejecutaba paso por paso.<br>
•	Todo el flujo del programa está controlado por estructuras lógicas, como condicionales (if) y bucles (while, for).<br>
•	En lugar de “objetos” o eventos, los datos y las acciones están organizados en procedimientos o funciones.<br>
• ¿Por qué es importante si estamos viendo desarrollo móvil?<br>
Aunque hoy usamos lenguajes modernos (como Kotlin, Swift, JavaScript), la lógica detrás del comportamiento de una app todavía se basa en lo aprendido con la programación tradicional:<br>
•	Pensar como un algoritmo<br>
•	Entender el flujo del programa<br>
•	Saber descomponer problemas grandes en pasos pequeños<br>
Relación con juegos clásicos como Pac-Man
Tu compañero tiene razón. Juegos como Pac-Man, Space Invaders, Tetris o Donkey Kong fueron creados con programación tradicional.</p>
   <br>  
<img src="1745927420811.png" alt="Preguntas sobre programación" class="hero-image">
           
</div>
        <!-- Resto de preguntas -->
             <div class="content-grid">
        <div class="example-card">
            <h3>¿Por qué?</h3>
            <p>•	No existía todavía la programación orientada a objetos.<br>
•	El código se escribía en lenguajes como C o Assembly.<br>
•	Se manejaban las posiciones de los personajes (como Pac-Man o los fantasmas) usando coordenadas, condicionales, y bucles infinitos para detectar colisiones, movimientos y límites.<br>
Ejemplo (simplificado) del algoritmo de Pac-Man:<br>
Inicio<br>
  Mientras (el juego no ha terminado)<br>
     Leer tecla del jugador<br>
     Mover Pac-Man en dirección<br>
     Mover fantasmas<br>
     Si Pac-Man choca con fantasma<br>
         Terminar juego<br>
     Si Pac-Man come punto<br>
         Sumar puntos<br>
  FinMientras<br>
Fin</p>
        <br>  
<img src="pacman-namco.gif" alt="Preguntas sobre programación" class="hero-image">
        </div>
        <div class="content-grid">
        <div class="example-card">
            <h3>Ejemplo practico </h3>
            <p>Todo eso se resolvía sin objetos, ni eventos, solo con estructuras básicas y lógica condicional.<br>
1.	Calentar agua<br>
2.	Colocar café en la taza<br>
3.	Verter agua caliente<br>
4.	Agregar azúcar<br>
5.	Mezclar<br>
Cada paso es una instrucción. Esto se parece mucho a una función en un lenguaje estructurado.
En pseudocódigo:<br>
Inicio<br>
  CalentarAgua()<br>
  ColocarCafe()<br>
  VerterAgua()<br>
  AgregarAzucar()<br>
  Mezclar()<br>
Fin</p>
        <br>  
         <br> 
          <br> 
           <br> 
            <br> 
<img src="WhatsApp Image 2025-09-07 at 8.15.06 PM.jpeg" alt="Preguntas sobre programación" class="hero-image">
        </div>
         
    </div>
     <div class="content-grid">
        <div class="example-card">
            <h3>¿Cómo se conecta con el desarrollo móvil? </h3>
            <p>Desarrollo móvil = programación orientada a eventos y objetos.<br>
Pero para llegar ahí, necesitas saber:<br>
•	Cómo organizar la lógica de un programa<br>
•	Cómo funciona una estructura condicional<br>
•	Cómo repetir procesos (bucles)<br>
•	Cómo dividir un problema en pequeñas funciones
Todo eso viene de la programación tradicional.<br>
Fin</p>
        <br> 
         <br> 
          <br> 
           <br> 
            <br> 
             <br>
              <br> 
               <br>  
                <br> 
              <br>  
<img src="istock-495081436-900x600.jpg" alt="Preguntas sobre programación" class="hero-image">
        </div>
        
    </div>
    
</div>

            </div>
            <!-- TAB 7: PREGUNTAS -->
<!-- TAB 7: PREGUNTAS -->
<div class="tab-content">
    <video class="hero-video" controls autoplay muted loop>
        <source src="Programacion tradicional .mp4" type="video/mp4">
        Tu navegador no soporta el video.
    </video>
</div>

    </div>
        </div>  
        
    </nav>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 Historia de la Programación Tradicional. Una mirada al pasado que construyó nuestro presente digital.</p>
        </div>
    </footer>
</body>
</html>